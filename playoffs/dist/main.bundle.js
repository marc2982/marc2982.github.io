/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ var __webpack_modules__ = ({

/***/ "./js/common.ts":
/*!**********************!*\
  !*** ./js/common.ts ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   excelRank: () => (/* binding */ excelRank)\n/* harmony export */ });\nfunction excelRank(values, target) {\n    const sortedValues = [...values].sort((a, b) => b - a);\n    for (let i = 0; i < sortedValues.length; i++) {\n        if (sortedValues[i] === target) {\n            return i + 1;\n        }\n    }\n    throw new Error(\"cant calculate excel ranking\");\n}\n\n\n//# sourceURL=webpack:///./js/common.ts?");

/***/ }),

/***/ "./js/csvProcessor.ts":
/*!****************************!*\
  !*** ./js/csvProcessor.ts ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   loadCsv: () => (/* binding */ loadCsv),\n/* harmony export */   loadData: () => (/* binding */ loadData)\n/* harmony export */ });\n/* harmony import */ var _vanillaes_csv__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @vanillaes/csv */ \"./node_modules/@vanillaes/csv/index.js\");\n/* harmony import */ var _models__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./models */ \"./js/models.ts\");\n/* harmony import */ var _nhlApiHandler__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./nhlApiHandler */ \"./js/nhlApiHandler.ts\");\n/* harmony import */ var _picksImporter__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./picksImporter */ \"./js/picksImporter.ts\");\n/* harmony import */ var _summarizer__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./summarizer */ \"./js/summarizer.ts\");\n/* harmony import */ var _projectionCalculator__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./projectionCalculator */ \"./js/projectionCalculator.ts\");\n\n\n\n\n\n\nasync function loadData(year) {\n    try {\n        const data = await $.getJSON('./overall.json');\n        return yearlySummaryFromJson(year, data);\n    }\n    catch (err) {\n        console.error(\"Failed to load overall.json, falling back to CSV processing:\", err);\n        return await loadAndProcessCsvs(year);\n    }\n}\n// TODO\nfunction yearlySummaryFromJson(year, json) {\n    return _models__WEBPACK_IMPORTED_MODULE_1__.YearlySummary.create({\n        year: year,\n        rounds: [],\n        personSummaries: {},\n        winners: [],\n        losers: [],\n        tiebreakInfo: _models__WEBPACK_IMPORTED_MODULE_1__.TiebreakInfo.create({}),\n        projections: {},\n        teams: {}\n    });\n}\nasync function loadAndProcessCsvs(year) {\n    const api = new _nhlApiHandler__WEBPACK_IMPORTED_MODULE_2__.NhlApiHandler(year);\n    await api.load();\n    const picksImporter = new _picksImporter__WEBPACK_IMPORTED_MODULE_3__.PicksImporter(api);\n    const summarizer = new _summarizer__WEBPACK_IMPORTED_MODULE_4__.Summarizer(year, api);\n    const projector = new _projectionCalculator__WEBPACK_IMPORTED_MODULE_5__.ProjectionCalculator(api);\n    const rounds = [];\n    for (let roundNum = 1; roundNum <= 4; roundNum++) { // 4 rounds in the playoffs\n        const scoring = _models__WEBPACK_IMPORTED_MODULE_1__.SCORING[roundNum - 1];\n        const seriesLetters = _models__WEBPACK_IMPORTED_MODULE_1__.ALL_SERIES[roundNum - 1];\n        const serieses = seriesLetters.map(letter => api.getSeries(letter));\n        const picks = await picksImporter.readCsv('.', roundNum);\n        const pickResults = buildPickResults(scoring, api, picks);\n        const summary = summarizer.summarizeRound(pickResults);\n        rounds.push(_models__WEBPACK_IMPORTED_MODULE_1__.Round.create({\n            number: roundNum,\n            serieses: serieses,\n            pickResults: pickResults,\n            scoring: scoring,\n            summary: summary\n        }));\n    }\n    const projections = projector.calculate(rounds);\n    console.log(\"Projections:\", projections);\n    return summarizer.summarizeYear(rounds, projections);\n}\nasync function loadCsv(filename) {\n    try {\n        const data = await $.get(filename);\n        return (0,_vanillaes_csv__WEBPACK_IMPORTED_MODULE_0__.parse)(data);\n    }\n    catch (err) {\n        console.error(`Failed to load CSV file ${filename}:`, err);\n        throw err;\n    }\n}\nfunction buildPickResults(scoring, api, picks) {\n    const pickResults = {};\n    for (const [person, picksBySeries] of Object.entries(picks)) {\n        for (const [seriesLetter, pick] of Object.entries(picksBySeries)) {\n            const series = api.getSeries(seriesLetter);\n            const winner = series.getWinner();\n            const teamStatus = getTeamStatus(pick, winner);\n            const gamesStatus = getGamesStatus(pick, winner, series);\n            const points = getPoints(scoring, teamStatus, gamesStatus);\n            const possiblePoints = winner\n                ? points\n                : calculatePossiblePoints(pick, series, scoring, teamStatus, gamesStatus);\n            if (!pickResults[person]) {\n                pickResults[person] = {};\n            }\n            pickResults[person][series.letter] = _models__WEBPACK_IMPORTED_MODULE_1__.PickResult.create({\n                pick: pick,\n                teamStatus: teamStatus,\n                gamesStatus: gamesStatus,\n                points: points,\n                possiblePoints: possiblePoints\n            });\n        }\n    }\n    return pickResults;\n}\nfunction getPickStatus(pick, winner, predicate) {\n    if (!winner) {\n        return _models__WEBPACK_IMPORTED_MODULE_1__.PickStatus.UNKNOWN;\n    }\n    return predicate(pick, winner) ? _models__WEBPACK_IMPORTED_MODULE_1__.PickStatus.CORRECT : _models__WEBPACK_IMPORTED_MODULE_1__.PickStatus.INCORRECT;\n}\nfunction getTeamStatus(pick, winner) {\n    return getPickStatus(pick, winner, (p, w) => p.team === w.team);\n}\nfunction getGamesStatus(pick, winner, series) {\n    // sometimes we can assign correctness early\n    if (winner === null) {\n        const gamesPlayed = series.totalGames();\n        // since we know the 7th game will be the last we can give points early\n        if (gamesPlayed === 6 && pick.games === 7) {\n            return _models__WEBPACK_IMPORTED_MODULE_1__.PickStatus.CORRECT;\n        }\n        // if >= games than the guess have been played, it's a bad guess\n        if (gamesPlayed >= pick.games) {\n            return _models__WEBPACK_IMPORTED_MODULE_1__.PickStatus.INCORRECT;\n        }\n        // certain games become impossible, ie both teams win 1 each so 4 games is impossible\n        const minGamesForWinner = Math.min(series.topSeedWins, series.bottomSeedWins) + 4;\n        if (pick.games < minGamesForWinner) {\n            return _models__WEBPACK_IMPORTED_MODULE_1__.PickStatus.INCORRECT;\n        }\n    }\n    return getPickStatus(pick, winner, (p, w) => p.games === w.games);\n}\nfunction getPoints(scoring, teamStatus, gamesStatus) {\n    const correctTeam = teamStatus === _models__WEBPACK_IMPORTED_MODULE_1__.PickStatus.CORRECT;\n    const correctGames = gamesStatus === _models__WEBPACK_IMPORTED_MODULE_1__.PickStatus.CORRECT;\n    let points = 0;\n    points += correctTeam ? scoring.team : 0;\n    points += correctGames ? scoring.games : 0;\n    points += (correctTeam && correctGames) ? scoring.bonus : 0;\n    return points;\n}\n// this function should ONLY be called when there is no winner\nfunction calculatePossiblePoints(pick, series, scoring, teamStatus, gamesStatus) {\n    const possibleFromTeam = [_models__WEBPACK_IMPORTED_MODULE_1__.PickStatus.CORRECT, _models__WEBPACK_IMPORTED_MODULE_1__.PickStatus.UNKNOWN].includes(teamStatus) ? scoring.team : 0;\n    const possibleFromGames = [_models__WEBPACK_IMPORTED_MODULE_1__.PickStatus.CORRECT, _models__WEBPACK_IMPORTED_MODULE_1__.PickStatus.UNKNOWN].includes(gamesStatus) ? scoring.games : 0;\n    const [currentLoserTeam, currentLoserWins, currentLeaderTeam, currentLeaderWins] = series.topSeedWins < series.bottomSeedWins\n        ? [series.bottomSeed, series.bottomSeedWins, series.topSeed, series.topSeedWins]\n        : [series.topSeed, series.topSeedWins, series.bottomSeed, series.bottomSeedWins];\n    const numGamesLeaderNeeds = 4 - currentLeaderWins;\n    const numGamesLoserNeeds = 4 - currentLoserWins;\n    const isLoserBonusPossible = (pick.team === currentLoserTeam &&\n        pick.games >= (numGamesLoserNeeds + currentLoserWins + currentLeaderWins));\n    const isLeaderBonusPossible = (pick.team === currentLeaderTeam &&\n        pick.games >= (numGamesLeaderNeeds + currentLeaderWins + currentLoserWins));\n    const isBonusPossible = isLoserBonusPossible || isLeaderBonusPossible;\n    return isBonusPossible\n        ? possibleFromTeam + possibleFromGames + scoring.bonus\n        : Math.max(possibleFromTeam, possibleFromGames);\n}\n\n\n//# sourceURL=webpack:///./js/csvProcessor.ts?");

/***/ }),

/***/ "./js/main.ts":
/*!********************!*\
  !*** ./js/main.ts ***!
  \********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   render: () => (/* binding */ render)\n/* harmony export */ });\n/* harmony import */ var _year__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./year */ \"./js/year.ts\");\n/* harmony import */ var _csvProcessor__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./csvProcessor */ \"./js/csvProcessor.ts\");\n\n\nasync function render(year) {\n    const data = await (0,_csvProcessor__WEBPACK_IMPORTED_MODULE_1__.loadData)(year);\n    (0,_year__WEBPACK_IMPORTED_MODULE_0__.renderPage)(data);\n}\n\n\n//# sourceURL=webpack:///./js/main.ts?");

/***/ }),

/***/ "./js/models.ts":
/*!**********************!*\
  !*** ./js/models.ts ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ALL_SERIES: () => (/* binding */ ALL_SERIES),\n/* harmony export */   PersonPointsSummary: () => (/* binding */ PersonPointsSummary),\n/* harmony export */   Pick: () => (/* binding */ Pick),\n/* harmony export */   PickResult: () => (/* binding */ PickResult),\n/* harmony export */   PickStatus: () => (/* binding */ PickStatus),\n/* harmony export */   ProjectionCell: () => (/* binding */ ProjectionCell),\n/* harmony export */   Round: () => (/* binding */ Round),\n/* harmony export */   RoundSummary: () => (/* binding */ RoundSummary),\n/* harmony export */   SCORING: () => (/* binding */ SCORING),\n/* harmony export */   Scoring: () => (/* binding */ Scoring),\n/* harmony export */   Series: () => (/* binding */ Series),\n/* harmony export */   Team: () => (/* binding */ Team),\n/* harmony export */   TiebreakInfo: () => (/* binding */ TiebreakInfo),\n/* harmony export */   WINNER_MAP: () => (/* binding */ WINNER_MAP),\n/* harmony export */   Winner: () => (/* binding */ Winner),\n/* harmony export */   YearlySummary: () => (/* binding */ YearlySummary)\n/* harmony export */ });\n/* harmony import */ var dataclass__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! dataclass */ \"./node_modules/dataclass/dataclass.module.js\");\n\nconst ALL_SERIES = [\n    [\"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\", \"H\"],\n    [\"I\", \"J\", \"K\", \"L\"],\n    [\"M\", \"N\"],\n    [\"O\"],\n];\nconst WINNER_MAP = {\n    'I': ['A', 'B'],\n    'J': ['C', 'D'],\n    'K': ['E', 'F'],\n    'L': ['G', 'H'],\n    'M': ['I', 'J'],\n    'N': ['K', 'L'],\n    'O': ['M', 'N']\n};\n// enum\nvar PickStatus;\n(function (PickStatus) {\n    PickStatus[\"CORRECT\"] = \"CORRECT\";\n    PickStatus[\"INCORRECT\"] = \"INCORRECT\";\n    PickStatus[\"UNKNOWN\"] = \"UNKNOWN\";\n})(PickStatus || (PickStatus = {}));\n;\n// dataclass library requires default values for some reason\nconst DEFAULT_STRING = \"DEFAULT_STRING\";\nconst DEFAULT_NUMBER = -9999;\nclass Pick extends dataclass__WEBPACK_IMPORTED_MODULE_0__.Data {\n    constructor() {\n        super(...arguments);\n        this.team = DEFAULT_STRING;\n        this.games = DEFAULT_NUMBER;\n    }\n}\nclass PickResult extends dataclass__WEBPACK_IMPORTED_MODULE_0__.Data {\n    constructor() {\n        super(...arguments);\n        this.pick = Pick.create({});\n        this.teamStatus = PickStatus.UNKNOWN;\n        this.gamesStatus = PickStatus.UNKNOWN;\n        this.points = DEFAULT_NUMBER;\n        this.possiblePoints = DEFAULT_NUMBER;\n        this.earnedBonusPoints = false;\n    }\n}\nclass Series extends dataclass__WEBPACK_IMPORTED_MODULE_0__.Data {\n    constructor() {\n        super(...arguments);\n        this.letter = DEFAULT_STRING;\n        this.topSeed = undefined;\n        this.bottomSeed = undefined;\n        this.topSeedWins = DEFAULT_NUMBER;\n        this.bottomSeedWins = DEFAULT_NUMBER;\n    }\n    getShortDesc() {\n        return `${this.topSeed} vs ${this.bottomSeed}`;\n    }\n    isOver() {\n        return this.isTopSeedWinner() || this.isBottomSeedWinner();\n    }\n    isTopSeedWinner() {\n        return !!this.topSeed && this.topSeedWins === 4;\n    }\n    isBottomSeedWinner() {\n        return !!this.bottomSeed && this.bottomSeedWins === 4;\n    }\n    totalGames() {\n        return this.topSeedWins + this.bottomSeedWins;\n    }\n    getWinner() {\n        if (this.isTopSeedWinner()) {\n            return Winner.create({ team: this.topSeed, games: this.totalGames() });\n        }\n        if (this.isBottomSeedWinner()) {\n            return Winner.create({ team: this.bottomSeed, games: this.totalGames() });\n        }\n        return null;\n    }\n    getTopSeedShort() {\n        return this.topSeed\n            ? `${this.topSeed} ${this.topSeedWins}`\n            : `Winner ${WINNER_MAP[this.letter][0]}`;\n    }\n    getBottomSeedShort() {\n        return this.bottomSeed\n            ? `${this.bottomSeed} ${this.bottomSeedWins}`\n            : `Winner ${WINNER_MAP[this.letter][1]}`;\n    }\n    getSeriesSummary() {\n        return `${this.getTopSeedShort()} - ${this.getBottomSeedShort()}`;\n    }\n}\nclass Team extends dataclass__WEBPACK_IMPORTED_MODULE_0__.Data {\n    constructor() {\n        super(...arguments);\n        this.name = DEFAULT_STRING;\n        this.short = DEFAULT_STRING;\n        this.logo = DEFAULT_STRING;\n        this.rank = DEFAULT_STRING;\n    }\n}\nclass Winner extends dataclass__WEBPACK_IMPORTED_MODULE_0__.Data {\n    constructor() {\n        super(...arguments);\n        this.team = DEFAULT_STRING;\n        this.games = DEFAULT_NUMBER;\n    }\n}\nclass ProjectionCell extends dataclass__WEBPACK_IMPORTED_MODULE_0__.Data {\n    constructor() {\n        super(...arguments);\n        this.first = [];\n        this.second = [];\n        this.third = [];\n        this.losers = [];\n        this.isPossible = undefined;\n        this.isOver = undefined;\n    }\n}\nclass Scoring extends dataclass__WEBPACK_IMPORTED_MODULE_0__.Data {\n    constructor() {\n        super(...arguments);\n        this.team = DEFAULT_NUMBER;\n        this.games = DEFAULT_NUMBER;\n        this.bonus = DEFAULT_NUMBER;\n    }\n}\nclass PersonPointsSummary extends dataclass__WEBPACK_IMPORTED_MODULE_0__.Data {\n    constructor() {\n        super(...arguments);\n        this.person = DEFAULT_STRING;\n        this.points = DEFAULT_NUMBER;\n        this.possiblePoints = DEFAULT_NUMBER;\n        this.rank = DEFAULT_NUMBER;\n        this.teamsCorrect = DEFAULT_NUMBER;\n        this.gamesCorrect = DEFAULT_NUMBER;\n        this.bonusEarned = DEFAULT_NUMBER;\n    }\n}\nclass RoundSummary extends dataclass__WEBPACK_IMPORTED_MODULE_0__.Data {\n    constructor() {\n        super(...arguments);\n        this.summaries = {};\n        this.winners = [];\n        this.losers = [];\n    }\n}\nclass Round extends dataclass__WEBPACK_IMPORTED_MODULE_0__.Data {\n    constructor() {\n        super(...arguments);\n        this.number = DEFAULT_NUMBER;\n        this.serieses = [];\n        this.pickResults = {};\n        this.scoring = Scoring.create({});\n        this.summary = RoundSummary.create({});\n    }\n}\nclass TiebreakInfo extends dataclass__WEBPACK_IMPORTED_MODULE_0__.Data {\n    constructor() {\n        super(...arguments);\n        this.leaders = [];\n        this.winner = undefined;\n    }\n}\nclass YearlySummary extends dataclass__WEBPACK_IMPORTED_MODULE_0__.Data {\n    constructor() {\n        super(...arguments);\n        this.year = DEFAULT_NUMBER;\n        this.rounds = [];\n        this.personSummaries = {};\n        this.winners = [];\n        this.losers = [];\n        this.tiebreakInfo = TiebreakInfo.create({});\n        this.projections = {};\n        this.teams = {};\n    }\n}\nconst SCORING = [\n    Scoring.create({ team: 1, games: 2, bonus: 3 }),\n    Scoring.create({ team: 2, games: 3, bonus: 4 }),\n    Scoring.create({ team: 3, games: 4, bonus: 5 }),\n    Scoring.create({ team: 4, games: 5, bonus: 6 })\n];\n\n\n//# sourceURL=webpack:///./js/models.ts?");

/***/ }),

/***/ "./js/nhlApiHandler.ts":
/*!*****************************!*\
  !*** ./js/nhlApiHandler.ts ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   NhlApiHandler: () => (/* binding */ NhlApiHandler)\n/* harmony export */ });\n/* harmony import */ var _models__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./models */ \"./js/models.ts\");\n\nconst NHL_API_URL = \"https://api-web.nhle.com/v1/playoff-bracket/{0}\"; // TODO\nconst TOP = \"top\";\nconst BOTTOM = \"bottom\";\nclass NhlApiHandler {\n    constructor(year) {\n        this.year = year;\n        this.url = NHL_API_URL.replace(\"{0}\", year.toString());\n        this.teams = {};\n        this.series = [];\n    }\n    async load() {\n        console.log(`Calling API: ${this.url}`);\n        const data = await $.get(this.url);\n        //const data = await $.getJSON(\"../dist/2025.json\");\n        for (const series of data.series) {\n            if (!series.seriesUrl) {\n                continue; // series not fully set yet\n            }\n            const topSeed = this.buildTeam(series, TOP);\n            const bottomSeed = this.buildTeam(series, BOTTOM);\n            this.series.push(_models__WEBPACK_IMPORTED_MODULE_0__.Series.create({\n                letter: series.seriesLetter,\n                topSeed: topSeed.short,\n                bottomSeed: bottomSeed.short,\n                topSeedWins: series.topSeedWins,\n                bottomSeedWins: series.bottomSeedWins\n            }));\n            if (series.seriesTitle === \"Stanley Cup Final\") {\n                break;\n            }\n        }\n        // add future series to the list\n        const existingLetters = this.series.map(s => s.letter);\n        for (let i = 0; i < _models__WEBPACK_IMPORTED_MODULE_0__.ALL_SERIES.length; i++) {\n            const round = _models__WEBPACK_IMPORTED_MODULE_0__.ALL_SERIES[i];\n            for (const seriesLetter of round) {\n                if (existingLetters.includes(seriesLetter)) {\n                    continue; // already have a record of it\n                }\n                this.series.push(_models__WEBPACK_IMPORTED_MODULE_0__.Series.create({\n                    letter: seriesLetter,\n                    topSeed: undefined,\n                    bottomSeed: undefined,\n                    topSeedWins: 0,\n                    bottomSeedWins: 0\n                }));\n            }\n        }\n    }\n    getTeams() {\n        return this.teams;\n    }\n    buildTeam(series, topOrBottom) {\n        const seed = series[`${topOrBottom}SeedTeam`];\n        const short = seed.abbrev;\n        // only need to load each team once\n        if (this.teams[short]) {\n            return this.teams[short];\n        }\n        const team = _models__WEBPACK_IMPORTED_MODULE_0__.Team.create({\n            name: seed.name.default,\n            short: short,\n            logo: seed.logo,\n            rank: series[`${topOrBottom}SeedRankAbbrev`]\n        });\n        this.teams[team.short] = team;\n        return team;\n    }\n    // teamPickStr matches the full name of the team in picks.csv\n    getTeam(teamPickStr) {\n        // handle team discrepancies between picks and api\n        // also handle older years when picks were only shorthand\n        const conversionMap = {\n            \"BUFF\": \"BUF\",\n            \"CAL\": \"CGY\",\n            \"CLB\": \"CBJ\",\n            \"LA\": \"LAK\",\n            \"LV\": \"VGK\",\n            \"MON\": \"MTL\",\n            \"Montreal Canadiens\": \"Montréal Canadiens\",\n            \"NAS\": \"NSH\",\n            \"NASH\": \"NSH\",\n            \"NJ\": \"NJD\",\n            \"PHE\": \"PHX\",\n            \"PHO\": \"PHX\",\n            \"PITT\": \"PIT\",\n            \"SJ\": \"SJS\",\n            \"St Louis Blues\": \"St. Louis Blues\",\n            \"TB\": \"TBL\",\n            \"WAS\": \"WSH\",\n            \"WASH\": \"WSH\",\n        };\n        teamPickStr = conversionMap[teamPickStr] || teamPickStr;\n        const foundTeam = Object.values(this.teams).find(team => teamPickStr === team.name || teamPickStr === team.short);\n        if (!foundTeam) {\n            throw new Error(`Could not find ${teamPickStr}`);\n        }\n        return foundTeam;\n    }\n    getSeries(letter) {\n        const foundSeries = this.series.find(series => series.letter === letter);\n        if (!foundSeries) {\n            throw new Error(`Series ${letter} not found`);\n        }\n        return foundSeries;\n    }\n    getSeriesOrNone(letter) {\n        try {\n            return this.getSeries(letter);\n        }\n        catch {\n            return null;\n        }\n    }\n    *seriesIter(round) {\n        const order = _models__WEBPACK_IMPORTED_MODULE_0__.ALL_SERIES[round - 1];\n        for (const letter of order) {\n            yield this.getSeries(letter);\n        }\n    }\n    getScfSeries() {\n        return this.getSeries(_models__WEBPACK_IMPORTED_MODULE_0__.ALL_SERIES[_models__WEBPACK_IMPORTED_MODULE_0__.ALL_SERIES.length - 1][0]);\n    }\n    getScfTeams() {\n        const teams = [];\n        for (const letter of _models__WEBPACK_IMPORTED_MODULE_0__.ALL_SERIES[2]) { // round 3 winners\n            const series = this.getSeriesOrNone(letter);\n            if (!series) {\n                continue;\n            }\n            const winner = series.getWinner();\n            if (!winner) {\n                continue;\n            }\n            teams.push(winner.team);\n        }\n        return teams;\n    }\n}\n\n\n//# sourceURL=webpack:///./js/nhlApiHandler.ts?");

/***/ }),

/***/ "./js/picksImporter.ts":
/*!*****************************!*\
  !*** ./js/picksImporter.ts ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   PicksImporter: () => (/* binding */ PicksImporter)\n/* harmony export */ });\n/* harmony import */ var _vanillaes_csv__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @vanillaes/csv */ \"./node_modules/@vanillaes/csv/index.js\");\n/* harmony import */ var _models__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./models */ \"./js/models.ts\");\n\n\nconst DEFAULT_ORDER = [['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H'], ['I', 'J', 'K', 'L'], ['M', 'N'], ['O']];\nclass PicksImporter {\n    constructor(api) {\n        this.api = api;\n    }\n    async readCsv(folderName, round) {\n        const filePath = `${folderName}/round${round}.csv`;\n        try {\n            const csvData = await this.readCsvFile(filePath);\n            return this.readPicks(csvData, round);\n        }\n        catch (error) {\n            console.error(`Error reading CSV for round ${round}:`, error);\n            return {};\n        }\n    }\n    async readCsvFile(filePath) {\n        const response = await fetch(filePath);\n        if (!response.ok) {\n            console.log(`Failed to load CSV file: ${filePath}`);\n            return [];\n        }\n        const csvText = await response.text();\n        const rows = (0,_vanillaes_csv__WEBPACK_IMPORTED_MODULE_0__.parse)(csvText);\n        rows.shift(); // Remove the first row (headers)\n        return rows;\n    }\n    readPicks(rows, round) {\n        const seriesOrder = this.getSeriesImportOrder(round);\n        const picks = {};\n        for (const row of rows) {\n            const person = this.standardizeName(row[1]);\n            const colIter = row.slice(2).values();\n            let i = 0;\n            for (const col of colIter) {\n                const teamName = this.stripRank(col);\n                const numGames = colIter.next().value;\n                const seriesLetter = seriesOrder[i];\n                if (typeof numGames !== 'string') {\n                    throw new Error(`Invalid games value for ${person} in series ${seriesLetter}`);\n                }\n                if (!picks[person]) {\n                    picks[person] = {};\n                }\n                picks[person][seriesLetter] = _models__WEBPACK_IMPORTED_MODULE_1__.Pick.create({\n                    team: this.api.getTeam(teamName).short,\n                    games: parseInt(numGames, 10)\n                });\n                i++;\n            }\n        }\n        return picks;\n    }\n    standardizeName(name) {\n        const lowerName = name.toLowerCase();\n        switch (lowerName) {\n            case \"dad\": return \"Derrick\";\n            case \"mom\":\n            case \"chris\": return \"Chrissy\";\n            case \"m.c.b.\": return \"Marc\";\n            default: return lowerName.charAt(0).toUpperCase() + lowerName.slice(1);\n        }\n    }\n    stripRank(teamName) {\n        const i = teamName.indexOf('(');\n        return i === -1 ? teamName : teamName.substring(0, i - 1);\n    }\n    getSeriesImportOrder(round) {\n        return DEFAULT_ORDER[round - 1];\n    }\n}\n\n\n//# sourceURL=webpack:///./js/picksImporter.ts?");

/***/ }),

/***/ "./js/projectionCalculator.ts":
/*!************************************!*\
  !*** ./js/projectionCalculator.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ProjectionCalculator: () => (/* binding */ ProjectionCalculator)\n/* harmony export */ });\n/* harmony import */ var _models__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./models */ \"./js/models.ts\");\n/* harmony import */ var _common__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./common */ \"./js/common.ts\");\n\n\nclass ProjectionCalculator {\n    constructor(nhlApiHandler) {\n        this.api = nhlApiHandler;\n    }\n    calculate(rounds) {\n        var _a;\n        const scfSeries = rounds[rounds.length - 1].serieses[0];\n        const scfTeams = [scfSeries.topSeed, scfSeries.bottomSeed];\n        console.log('rounds:', rounds);\n        console.log('SCF Series:', scfSeries);\n        console.log('SCF Teams:', scfTeams);\n        if (scfTeams.includes(undefined)) {\n            console.error('SCF Teams are undefined:', scfTeams);\n            return this.createEmptyTable();\n        }\n        console.log('calculate projections for SCF Teams:', scfTeams);\n        const thirdRoundPoints = this.calculateThirdRoundPoints(rounds);\n        const roundFourPicks = rounds[rounds.length - 1].pickResults;\n        const roundFourScoring = rounds[rounds.length - 1].scoring;\n        const projections = {};\n        for (let games = 4; games <= 7; games++) {\n            const cells = {};\n            for (const team of scfTeams) {\n                const points = { ...thirdRoundPoints };\n                for (const person in points) {\n                    const roundPick = (_a = roundFourPicks[person]) === null || _a === void 0 ? void 0 : _a['O'];\n                    if (roundPick) {\n                        points[person] += this.calculateFourthRound(roundFourScoring, roundPick.pick, team, games);\n                    }\n                    else {\n                        points[person] += 0;\n                    }\n                }\n                const allPoints = Object.values(points);\n                const rankMap = {};\n                for (const [person, score] of Object.entries(points)) {\n                    rankMap[person] = (0,_common__WEBPACK_IMPORTED_MODULE_1__.excelRank)(allPoints, score);\n                }\n                const loserRank = Math.max(...Object.values(rankMap).filter(rank => rank !== null));\n                cells[team] = _models__WEBPACK_IMPORTED_MODULE_0__.ProjectionCell.create({\n                    first: Object.entries(rankMap)\n                        .filter(([_, rank]) => rank === 1)\n                        .map(([person]) => `${person} (${points[person]} pts)`),\n                    second: Object.entries(rankMap)\n                        .filter(([_, rank]) => rank === 2)\n                        .map(([person]) => `${person} (${points[person]} pts)`),\n                    third: Object.entries(rankMap)\n                        .filter(([_, rank]) => rank === 3)\n                        .map(([person]) => `${person} (${points[person]} pts)`),\n                    losers: Object.entries(rankMap)\n                        .filter(([_, rank]) => rank === loserRank)\n                        .map(([person]) => `${person} (${points[person]} pts)`),\n                    isPossible: this.calculateIsPossible(team, games),\n                    isOver: scfSeries.isOver()\n                });\n            }\n            projections[games] = cells;\n        }\n        return projections;\n    }\n    calculateIsPossible(team, games) {\n        const scfSeries = this.api.getScfSeries();\n        if (scfSeries.isOver()) {\n            if (scfSeries.totalGames() !== games) {\n                return false;\n            }\n            return scfSeries.isTopSeedWinner()\n                ? team === scfSeries.topSeed\n                : team === scfSeries.bottomSeed;\n        }\n        const topSeed = { team: scfSeries.topSeed, wins: scfSeries.topSeedWins };\n        const bottomSeed = { team: scfSeries.bottomSeed, wins: scfSeries.bottomSeedWins };\n        let seed, otherSeed;\n        if (topSeed.team === team) {\n            seed = topSeed;\n            otherSeed = bottomSeed;\n        }\n        else {\n            seed = bottomSeed;\n            otherSeed = topSeed;\n        }\n        const minGamesToWin = (4 - seed.wins) + seed.wins + otherSeed.wins;\n        return games >= minGamesToWin;\n    }\n    calculateThirdRoundPoints(rounds) {\n        const points = {};\n        // Initialize all persons with 0 points\n        for (const round of rounds.slice(0, 3)) {\n            for (const person in round.summary.summaries) {\n                points[person] = 0;\n            }\n        }\n        // Accumulate points\n        for (const round of rounds.slice(0, 3)) {\n            for (const [person, summary] of Object.entries(round.summary.summaries)) {\n                points[person] += summary.points;\n            }\n        }\n        return points;\n    }\n    calculateFourthRound(scoring, pick, team, games) {\n        const teamPoints = pick.team === team ? scoring.team : 0;\n        const gamePoints = pick.games === games ? scoring.games : 0;\n        const bonusPoints = teamPoints > 0 && gamePoints > 0 ? scoring.bonus : 0;\n        return teamPoints + gamePoints + bonusPoints;\n    }\n    createEmptyTable() {\n        const result = {};\n        for (let games = 4; games <= 7; games++) {\n            result[games] = {\n                '': _models__WEBPACK_IMPORTED_MODULE_0__.ProjectionCell.create({\n                    first: ['-'],\n                    second: ['-'],\n                    third: ['-'],\n                    losers: ['-'],\n                    isPossible: undefined,\n                    isOver: false\n                })\n            };\n        }\n        console.log('Empty table:', result);\n        return result;\n    }\n}\n\n\n//# sourceURL=webpack:///./js/projectionCalculator.ts?");

/***/ }),

/***/ "./js/summarizer.ts":
/*!**************************!*\
  !*** ./js/summarizer.ts ***!
  \**************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Summarizer: () => (/* binding */ Summarizer)\n/* harmony export */ });\n/* harmony import */ var _models__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./models */ \"./js/models.ts\");\n/* harmony import */ var _common__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./common */ \"./js/common.ts\");\n\n\nclass Summarizer {\n    constructor(year, api) {\n        this.year = year;\n        this.teams = api.getTeams();\n    }\n    summarizeYear(rounds, projections) {\n        const points = {};\n        const possiblePoints = {};\n        const numTeamsCorrect = {};\n        const numGamesCorrect = {};\n        const numBonusCorrect = {};\n        // Initialize all records\n        for (const round of rounds) {\n            for (const person in round.summary.summaries) {\n                points[person] = 0;\n                possiblePoints[person] = 0;\n                numTeamsCorrect[person] = 0;\n                numGamesCorrect[person] = 0;\n                numBonusCorrect[person] = 0;\n            }\n        }\n        // Accumulate values\n        for (const round of rounds) {\n            for (const [person, summary] of Object.entries(round.summary.summaries)) {\n                points[person] += summary.points;\n                possiblePoints[person] += summary.possiblePoints;\n                numTeamsCorrect[person] += summary.teamsCorrect;\n                numGamesCorrect[person] += summary.gamesCorrect;\n                numBonusCorrect[person] += summary.bonusEarned;\n            }\n        }\n        const rankMap = calculateRankMapFromDict(points);\n        const personSummaries = {};\n        for (const person in numTeamsCorrect) {\n            personSummaries[person] = _models__WEBPACK_IMPORTED_MODULE_0__.PersonPointsSummary.create({\n                person: person,\n                points: points[person],\n                possiblePoints: possiblePoints[person],\n                rank: rankMap[person],\n                teamsCorrect: numTeamsCorrect[person],\n                gamesCorrect: numGamesCorrect[person],\n                bonusEarned: numBonusCorrect[person]\n            });\n        }\n        const winners = calculateAllWinners(rankMap);\n        return _models__WEBPACK_IMPORTED_MODULE_0__.YearlySummary.create({\n            year: this.year,\n            rounds: rounds,\n            personSummaries: personSummaries,\n            winners: winners,\n            losers: calculateLosers(rankMap),\n            tiebreakInfo: _models__WEBPACK_IMPORTED_MODULE_0__.TiebreakInfo.create({\n                leaders: winners,\n                winner: calculateWinner(personSummaries, winners)\n            }),\n            projections: projections,\n            teams: this.teams\n        });\n    }\n    summarizeRound(pickResults) {\n        const summaries = {};\n        for (const [person, pickResultsBySeries] of Object.entries(pickResults)) {\n            let real = 0;\n            let possible = 0;\n            let teamsCorrect = 0;\n            let gamesCorrect = 0;\n            let bonusEarned = 0;\n            for (const pickResult of Object.values(pickResultsBySeries)) {\n                real += pickResult.points;\n                possible += pickResult.possiblePoints;\n                teamsCorrect += pickResult.teamStatus === _models__WEBPACK_IMPORTED_MODULE_0__.PickStatus.CORRECT ? 1 : 0;\n                gamesCorrect += pickResult.gamesStatus === _models__WEBPACK_IMPORTED_MODULE_0__.PickStatus.CORRECT ? 1 : 0;\n                bonusEarned += pickResult.earnedBonusPoints ? 1 : 0;\n            }\n            summaries[person] = _models__WEBPACK_IMPORTED_MODULE_0__.PersonPointsSummary.create({\n                person: person,\n                points: real,\n                possiblePoints: possible,\n                rank: 0, // Temporary rank, will be updated\n                teamsCorrect: teamsCorrect,\n                gamesCorrect: gamesCorrect,\n                bonusEarned: bonusEarned\n            });\n        }\n        const pointsDict = Object.fromEntries(Object.entries(summaries).map(([person, summary]) => [person, summary.points]));\n        const rankMap = calculateRankMapFromDict(pointsDict);\n        // Update ranks\n        for (const person in summaries) {\n            const summary = summaries[person];\n            summaries[person] = _models__WEBPACK_IMPORTED_MODULE_0__.PersonPointsSummary.create({\n                person: summary.person,\n                points: summary.points,\n                possiblePoints: summary.possiblePoints,\n                rank: rankMap[person],\n                teamsCorrect: summary.teamsCorrect,\n                gamesCorrect: summary.gamesCorrect,\n                bonusEarned: summary.bonusEarned\n            });\n        }\n        return _models__WEBPACK_IMPORTED_MODULE_0__.RoundSummary.create({\n            summaries: summaries,\n            winners: calculateAllWinners(rankMap),\n            losers: calculateLosers(rankMap)\n        });\n    }\n}\nfunction calculateAllWinners(rankMap) {\n    return Object.entries(rankMap)\n        .filter(([_, rank]) => rank === 1)\n        .map(([person]) => person);\n}\nfunction calculateWinner(allSummaries, winners) {\n    const winnersSummaries = winners.map(person => allSummaries[person]);\n    if (winnersSummaries.length === 1) {\n        return winnersSummaries[0].person;\n    }\n    // First tiebreaker: games correct\n    const numGamesMap = Object.fromEntries(winnersSummaries.map(s => [s.person, s.gamesCorrect]));\n    const maxGames = Math.max(...Object.values(numGamesMap));\n    const newLeaders = Object.entries(numGamesMap)\n        .filter(([_, games]) => games === maxGames)\n        .map(([person]) => person);\n    if (newLeaders.length === 1) {\n        return newLeaders[0];\n    }\n    // Second tiebreaker: teams correct\n    const numTeamsMap = Object.fromEntries(winnersSummaries.map(s => [s.person, s.teamsCorrect]));\n    const maxTeams = Math.max(...Object.values(numTeamsMap));\n    const finalLeaders = Object.entries(numTeamsMap)\n        .filter(([_, teams]) => teams === maxTeams)\n        .map(([person]) => person);\n    if (finalLeaders.length === 1) {\n        return finalLeaders[0];\n    }\n    return undefined;\n}\nfunction calculateLosers(rankMap) {\n    if (Object.keys(rankMap).length === 0) {\n        return [];\n    }\n    const lowestRank = Math.max(...Object.values(rankMap));\n    return Object.entries(rankMap)\n        .filter(([_, rank]) => rank === lowestRank)\n        .map(([person]) => person);\n}\nfunction calculateRankMapFromDict(d) {\n    const allPoints = Object.values(d);\n    return Object.fromEntries(Object.entries(d).map(([person, points]) => [\n        person,\n        (0,_common__WEBPACK_IMPORTED_MODULE_1__.excelRank)(allPoints, points)\n    ]));\n}\n\n\n//# sourceURL=webpack:///./js/summarizer.ts?");

/***/ }),

/***/ "./js/year.ts":
/*!********************!*\
  !*** ./js/year.ts ***!
  \********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   renderPage: () => (/* binding */ renderPage),\n/* harmony export */   renderProjections: () => (/* binding */ renderProjections),\n/* harmony export */   renderRound: () => (/* binding */ renderRound),\n/* harmony export */   renderSummary: () => (/* binding */ renderSummary),\n/* harmony export */   renderTiebreaker: () => (/* binding */ renderTiebreaker)\n/* harmony export */ });\nconst extraStatsColumns = { targets: [-1, -2, -3, -4], width: '5%' };\nfunction renderPage(data) {\n    renderTiebreaker(data, $('#tiebreaker'));\n    renderSummary(data, $('#summaryTable'));\n    $.each(data.rounds, function (_, round) {\n        let tableName = '#round' + round.number + 'Table';\n        renderRound(data.teams, round, $(tableName));\n    });\n    renderProjections(data, $('#projectionsTable'));\n}\nfunction renderTiebreaker(data, div) {\n    var _a, _b, _c;\n    if (((_c = (_b = (_a = data.tiebreakInfo) === null || _a === void 0 ? void 0 : _a.leaders) === null || _b === void 0 ? void 0 : _b.length) !== null && _c !== void 0 ? _c : 0) > 1) {\n        div.show();\n    }\n    else {\n        div.hide();\n    }\n}\nfunction getProjectionsClass(cell) {\n    if (!cell.isPossible) {\n        return 'incorrect';\n    }\n    else if (cell.isOver) {\n        return 'correct';\n    }\n    else {\n        return '';\n    }\n}\nfunction renderSummary(data, table) {\n    $(table).html(`\n        <thead>\n            <tr>\n                <th>&nbsp;</th>\n                <th>Round 1</th>\n                <th>Round 2</th>\n                <th>Round 3</th>\n                <th>Round 4</th>\n                <th>Total Points</th>\n                <th>Rank</th>\n                <th>Maximum Possible Points</th>\n                <th>Num Games Correct</th>\n                <th>Num Teams Correct</th>\n                <th>Num Bonuses Earned</th>\n            </tr>\n        </thead>\n        <tbody>\n            ${$.map(data.personSummaries, function (summary, person) {\n        var _a;\n        let leaderClass = person === ((_a = data.tiebreakInfo) === null || _a === void 0 ? void 0 : _a.winner) ? \"class='leader'\" : '';\n        return `<tr ${leaderClass}>\n                        <th>${person}</th>\n                        ${$.map(data.rounds, function (round) {\n            let summaries = round.summary.summaries;\n            return `<td>${person in summaries ? summaries[person].points : 0}</td>`;\n        })}\n                        <td>${summary.points}</td>\n                        <td>${summary.rank}</td>\n                        <td>${summary.possiblePoints}</td>\n                        <td>${summary.gamesCorrect}</td>\n                        <td>${summary.teamsCorrect}</td>\n                        <td>${summary.bonusEarned}</td>\n                    </tr>`;\n    }).join('')}\n        </tbody>\n    `);\n    $(table).DataTable({\n        paging: false,\n        searching: false,\n        info: false,\n        order: [\n            [5, 'desc'],\n            [8, 'desc'],\n            [9, 'desc'],\n        ],\n        ordering: true,\n        autoWidth: false,\n        columnDefs: [\n            { targets: [5, 6], className: 'dt-body-center dt-head-center points' },\n            extraStatsColumns,\n            { targets: '*', className: 'dt-body-center dt-head-center' },\n        ],\n    });\n}\nfunction renderRound(teams, round, table) {\n    var sortedSeries = round.serieses.sort((a, b) => (a.letter > b.letter ? 1 : -1));\n    if (!round.pickResults) {\n        console.log('No pick results for round ' + round.number);\n        return;\n    }\n    $(table).html(`\n        <thead>\n            <tr>\n                <th>&nbsp;</th>\n                ${$.map(round.serieses, function (series) {\n        const winningSeedClass = 'winning_seed';\n        let topSeedClass = series.topSeedWins == 4 ? winningSeedClass : '';\n        let bottomSeedClass = series.bottomSeedWins == 4 ? winningSeedClass : '';\n        return `<th>\n                            <span>Series ${series.letter}: </span>\n                            <br />\n                            ${series.topSeed ? `<span class='${topSeedClass}'>${series.topSeed} ${series.topSeedWins}</span>` : `<span>?</span>`}\n                            <br />\n                            ${series.bottomSeed ? `<span class='${bottomSeedClass}'>${series.bottomSeed} ${series.bottomSeedWins}</span>` : `<span>?</span>`}\n                        </th>`;\n    })}\n                <th>Points</th>\n                <th>Rank</th>\n                <th>Maximum Possible Points</th>\n                <th>Num Games Correct</th>\n                <th>Num Teams Correct</th>\n                <th>Num Bonuses Earned</th>\n            </tr>\n        </thead>\n        <tbody>\n            ${$.map(round.pickResults, function (results, person) {\n        let summary = round.summary.summaries[person];\n        let leaderClass = round.summary.winners.includes(person) && summary.points > 0 ? \"class='leader'\" : '';\n        return `<tr ${leaderClass}>\n                        <th>${person}</th>\n                        ${$.map(sortedSeries, function (series, _) {\n            var _a, _b, _c;\n            let seriesResult = results[series.letter];\n            let pick = seriesResult.pick;\n            let team = (_a = teams[pick.team]) === null || _a === void 0 ? void 0 : _a.short;\n            let teamLogo = (_b = teams[pick.team]) === null || _b === void 0 ? void 0 : _b.logo;\n            let teamName = (_c = teams[pick.team]) === null || _c === void 0 ? void 0 : _c.name;\n            return `<td>\n                                <div class=\"pick\">\n                                    <div class=\"img_container ${seriesResult.teamStatus.toLowerCase()}\">\n                                        ${teams[team] ? `<img src=\"${teamLogo}\" alt=\"${teamName}\" />` : '&nbsp;'}\n                                    </div>\n                                    <div class=\"games ${seriesResult.gamesStatus.toLowerCase()}\">${pick.games}</div>\n                                </div>\n                                </td>`;\n        })}\n                        <td>${summary.points}</td>\n                        <td>${summary.rank}</td>\n                        <td>${summary.possiblePoints}</td>\n                        <td>${summary.gamesCorrect}</td>\n                        <td>${summary.teamsCorrect}</td>\n                        <td>${summary.bonusEarned}</td>\n                    </tr>`;\n    }).join('')}\n        </tbody>\n    `);\n    let pointsColumns = { targets: [], className: '' };\n    let orderable = { orderable: true, targets: [] };\n    switch (round.number) {\n        case 1:\n            pointsColumns = { targets: [9, 10], className: 'dt-body-center dt-head-center points' };\n            orderable = { orderable: false, targets: [1, 2, 3, 4, 5, 6, 7, 8] };\n            break;\n        case 2:\n            pointsColumns = { targets: [5, 6], className: 'dt-body-center dt-head-center points' };\n            orderable = { orderable: false, targets: [1, 2, 3, 4] };\n            break;\n        case 3:\n            pointsColumns = { targets: [3, 4], className: 'dt-body-center dt-head-center points' };\n            orderable = { orderable: false, targets: [1, 2] };\n            break;\n        case 4:\n            pointsColumns = { targets: [2, 3], className: 'dt-body-center dt-head-center points' };\n            orderable = { orderable: false, targets: [1] };\n            break;\n    }\n    $(table).DataTable({\n        paging: false,\n        searching: false,\n        info: false,\n        order: [[0, 'asc']], // sort rounds by name\n        ordering: true,\n        autoWidth: false,\n        columnDefs: [\n            pointsColumns,\n            orderable,\n            extraStatsColumns,\n            { targets: '*', className: 'dt-body-center dt-head-center' },\n        ],\n    });\n}\nfunction renderProjectionCell(cell) {\n    return `<div>\n        <table style=\"width: 100%\">\n            <tbody>\n                <tr>\n                    <td style=\"width: 50%\">1st: ${cell.first.join()}</td>\n                    <td style=\"width: 50%\" rowspan=3>Loser(s): ${cell.losers.join()}</td>\n                </tr>\n                <tr>\n                    <td>2nd: ${cell.second.join()}</td>\n                </tr>\n                <tr>\n                    <td>3rd: ${cell.third.join()}</td>\n                </tr>\n            </tbody>\n        </table>\n    </div>`;\n}\nfunction renderProjections(data, table) {\n    console.log('Rendering projections');\n    console.log(data.projections);\n    if (!data.projections || !data.projections[4]) {\n        console.log('No projections data');\n        $(table).html('<p>No projections data</p>');\n        return;\n    }\n    let sortedGames = Object.keys(data.projections).map(key => Number(key)).sort((a, b) => a - b); // sort 4 -> 7\n    let teams = Object.keys(data.projections[4] || {}).sort(); // sort teams alphabetically\n    if (teams.length === 0 || teams[0] === '' || teams[1] === '') {\n        $(table).html('<p align=center>Awaiting Stanley Cup Final matchup.</p>');\n        return;\n    }\n    $(table).html(`\n        <thead>\n            <tr>\n                <th>&nbsp;</th>\n                ${$.map(teams, function (team) {\n        return `<th>\n                            <div class=\"pick\">\n                                ${data.teams[team] ? `<img src=\"${data.teams[team].logo}\" alt=\"${data.teams[team].name}\" />` : '&nbsp;'}\n                            </div>\n                        </th>`;\n    })}\n            </tr>\n        </thead>\n        <tbody>\n            ${$.map(sortedGames, function (game) {\n        return `<tr>\n                        <td>${game}</td>\n                        ${$.map(data.projections[game], function (cell, team) {\n            let tdClass = getProjectionsClass(cell);\n            let renderedCell = renderProjectionCell(cell);\n            return `<td class=\"${tdClass}\">${renderedCell}</td>`;\n        })}\n                    </tr>`;\n    }).join('')}\n        </tbody>\n    `);\n    $(table).DataTable({\n        paging: false,\n        searching: false,\n        info: false,\n        order: [[1, 'asc']],\n        ordering: false,\n        autoWidth: false,\n        columnDefs: [\n            { targets: [1, 2], type: 'html' },\n            { targets: '*', className: 'dt-body-center dt-head-center' },\n        ],\n    });\n}\n\n\n//# sourceURL=webpack:///./js/year.ts?");

/***/ }),

/***/ "./node_modules/@vanillaes/csv/index.js":
/*!**********************************************!*\
  !*** ./node_modules/@vanillaes/csv/index.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   parse: () => (/* binding */ parse),\n/* harmony export */   stringify: () => (/* binding */ stringify)\n/* harmony export */ });\n/**\n * Parse takes a string of CSV data and converts it to a 2 dimensional array\n *\n * options\n * - typed - infer types [false]\n *\n * @static\n * @param {string} csv the CSV string to parse\n * @param {Object} [options] an object containing the options\n * @param {Function} [reviver] a custom function to modify the values\n * @returns {Array} a 2 dimensional array of `[entries][values]`\n */\nfunction parse (csv, options, reviver = v => v) {\n  const ctx = Object.create(null)\n  ctx.options = options || {}\n  ctx.reviver = reviver\n  ctx.value = ''\n  ctx.entry = []\n  ctx.output = []\n  ctx.col = 1\n  ctx.row = 1\n\n  const lexer = /\"|,|\\r\\n|\\n|\\r|[^\",\\r\\n]+/y\n  const isNewline = /^(\\r\\n|\\n|\\r)$/\n\n  let matches = []\n  let match = ''\n  let state = 0\n\n  while ((matches = lexer.exec(csv)) !== null) {\n    match = matches[0]\n\n    switch (state) {\n      case 0: // start of entry\n        switch (true) {\n          case match === '\"':\n            state = 3\n            break\n          case match === ',':\n            state = 0\n            valueEnd(ctx)\n            break\n          case isNewline.test(match):\n            state = 0\n            valueEnd(ctx)\n            entryEnd(ctx)\n            break\n          default:\n            ctx.value += match\n            state = 2\n            break\n        }\n        break\n      case 2: // un-delimited input\n        switch (true) {\n          case match === ',':\n            state = 0\n            valueEnd(ctx)\n            break\n          case isNewline.test(match):\n            state = 0\n            valueEnd(ctx)\n            entryEnd(ctx)\n            break\n          default:\n            state = 4\n            throw Error(`CSVError: Illegal state [row:${ctx.row}, col:${ctx.col}]`)\n        }\n        break\n      case 3: // delimited input\n        switch (true) {\n          case match === '\"':\n            state = 4\n            break\n          default:\n            state = 3\n            ctx.value += match\n            break\n        }\n        break\n      case 4: // escaped or closing delimiter\n        switch (true) {\n          case match === '\"':\n            state = 3\n            ctx.value += match\n            break\n          case match === ',':\n            state = 0\n            valueEnd(ctx)\n            break\n          case isNewline.test(match):\n            state = 0\n            valueEnd(ctx)\n            entryEnd(ctx)\n            break\n          default:\n            throw Error(`CSVError: Illegal state [row:${ctx.row}, col:${ctx.col}]`)\n        }\n        break\n    }\n  }\n\n  // flush the last value\n  if (ctx.entry.length !== 0) {\n    valueEnd(ctx)\n    entryEnd(ctx)\n  }\n\n  return ctx.output\n}\n\n/**\n * Stringify takes a 2 dimensional array of `[entries][values]` and converts them to CSV\n *\n * options\n * - eof - add a trailing newline at the end of file [true]\n *\n * @static\n * @param {Array} array the input array to stringify\n * @param {Object} [options] an object containing the options\n * @param {Function} [replacer] a custom function to modify the values\n * @returns {string} the CSV string\n */\nfunction stringify (array, options = {}, replacer = v => v) {\n  const ctx = Object.create(null)\n  ctx.options = options\n  ctx.options.eof = ctx.options.eof !== undefined ? ctx.options.eof : true\n  ctx.row = 1\n  ctx.col = 1\n  ctx.output = ''\n\n  const needsDelimiters = /\"|,|\\r\\n|\\n|\\r/\n\n  array.forEach((row, rIdx) => {\n    let entry = ''\n    ctx.col = 1\n    row.forEach((col, cIdx) => {\n      if (typeof col === 'string') {\n        col = col.replace(/\"/g, '\"\"')\n        col = needsDelimiters.test(col) ? `\"${col}\"` : col\n      }\n      entry += replacer(col, ctx.row, ctx.col)\n      if (cIdx !== row.length - 1) {\n        entry += ','\n      }\n      ctx.col++\n    })\n    switch (true) {\n      case ctx.options.eof:\n      case !ctx.options.eof && rIdx !== array.length - 1:\n        ctx.output += `${entry}\\n`\n        break\n      default:\n        ctx.output += `${entry}`\n        break\n    }\n    ctx.row++\n  })\n\n  return ctx.output\n}\n\n/** @private */\nfunction valueEnd (ctx) {\n  const value = ctx.options.typed ? inferType(ctx.value) : ctx.value\n  ctx.entry.push(ctx.reviver(value, ctx.row, ctx.col))\n  ctx.value = ''\n  ctx.col++\n}\n\n/** @private */\nfunction entryEnd (ctx) {\n  ctx.output.push(ctx.entry)\n  ctx.entry = []\n  ctx.row++\n  ctx.col = 1\n}\n\n/** @private */\nfunction inferType (value) {\n  const isNumber = /.\\./\n\n  switch (true) {\n    case value === 'true':\n    case value === 'false':\n      return value === 'true'\n    case isNumber.test(value):\n      return parseFloat(value)\n    case isFinite(value):\n      return parseInt(value)\n    default:\n      return value\n  }\n}\n\n\n//# sourceURL=webpack:///./node_modules/@vanillaes/csv/index.js?");

/***/ }),

/***/ "./node_modules/dataclass/dataclass.module.js":
/*!****************************************************!*\
  !*** ./node_modules/dataclass/dataclass.module.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Data: () => (/* binding */ Data)\n/* harmony export */ });\nlet O = Object;\n\nlet produce = (proto, base, values) =>\n  O.freeze(O.assign(O.seal(O.assign(O.create(proto), base)), values));\n\nclass Data {\n  static create(values) {\n    return produce(this.prototype, new this(Data), values);\n  }\n\n  constructor(values) {\n    if (values !== Data) {\n      throw new Error(`Use ${this.constructor.name}.create(...) instead of new operator`);\n    }\n  }\n\n  copy(values) {\n    return produce(O.getPrototypeOf(this), this, values);\n  }\n\n  equals(other) {\n    for (let key in this) {\n      let a = this[key];\n      let b = other[key];\n      if (\n        a !== b &&\n        (a == null ||\n          b == null ||\n          (a instanceof Data && b instanceof Data ? !a.equals(b) : a.valueOf() !== b.valueOf()))\n      )\n        return false;\n    }\n\n    return true;\n  }\n}\n\n\n//# sourceURL=webpack:///./node_modules/dataclass/dataclass.module.js?");

/***/ })

/******/ });
/************************************************************************/
/******/ // The module cache
/******/ var __webpack_module_cache__ = {};
/******/ 
/******/ // The require function
/******/ function __webpack_require__(moduleId) {
/******/ 	// Check if module is in cache
/******/ 	var cachedModule = __webpack_module_cache__[moduleId];
/******/ 	if (cachedModule !== undefined) {
/******/ 		return cachedModule.exports;
/******/ 	}
/******/ 	// Create a new module (and put it into the cache)
/******/ 	var module = __webpack_module_cache__[moduleId] = {
/******/ 		// no module.id needed
/******/ 		// no module.loaded needed
/******/ 		exports: {}
/******/ 	};
/******/ 
/******/ 	// Execute the module function
/******/ 	__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 
/******/ 	// Return the exports of the module
/******/ 	return module.exports;
/******/ }
/******/ 
/************************************************************************/
/******/ /* webpack/runtime/define property getters */
/******/ (() => {
/******/ 	// define getter functions for harmony exports
/******/ 	__webpack_require__.d = (exports, definition) => {
/******/ 		for(var key in definition) {
/******/ 			if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 				Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 			}
/******/ 		}
/******/ 	};
/******/ })();
/******/ 
/******/ /* webpack/runtime/hasOwnProperty shorthand */
/******/ (() => {
/******/ 	__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ })();
/******/ 
/******/ /* webpack/runtime/make namespace object */
/******/ (() => {
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = (exports) => {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/ })();
/******/ 
/************************************************************************/
/******/ 
/******/ // startup
/******/ // Load entry module and return exports
/******/ // This entry module can't be inlined because the eval devtool is used.
/******/ var __webpack_exports__ = __webpack_require__("./js/main.ts");
/******/ const __webpack_exports__render = __webpack_exports__.render;
/******/ export { __webpack_exports__render as render };
/******/ 
